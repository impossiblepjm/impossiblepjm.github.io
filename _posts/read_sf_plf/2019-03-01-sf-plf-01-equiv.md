---
published: false
title: "ã€ŒSF-PLFã€? Equiv"
subtitle: "Programming Language Foundations - Program Equivalence (ç¨‹åºçš„ç­‰ä»·å…³ç³?"
layout: post
author: "Hux"
header-style: text
hidden: true
tags:
  - SF (è½¯ä»¶åŸºç¡€)
  - PLF (ç¼–ç¨‹è¯­è¨€åŸºç¡€)
  - Coq
  - ç¬”è®°
---

### issues on `coqc` module linking

Some module (e.g.`Map`) not found
either maunally `make map.vo` or proof general can solve that.



Behavioral Equivalence è¡Œä¸ºç­‰ä»·
---------------------------

> How to define _the correctness of program transformation_, e.g. `optimize_0plus` ?
- in the setting w/o var (imp w/o var and state) : yield a program the evals to same number as original.
- in the setting w/ var (full imp w/ assignment) : we need to consider the role of var and state.

### Definitions

> Two `aexps` or `bexps` are _behaviorally equivalent_ if they evaluate to the same result __in every state__.

```coq
Definition aequiv (a1 a2 : aexp) : Prop :=
  âˆ€(st : state), aeval st a1 = aeval st a2.
Definition bequiv (b1 b2 : bexp) : Prop :=
  âˆ€(st : state), beval st b1 = beval st b2.
```

> For commands, We can't simply say ... if they evaluate to the same ending state
> __some commands don't terminate in any final state at all!__

So to define, they either or...
1. both diverge éƒ½å‘æ•?
2. both terminate in the same final state éƒ½åœ¨åŒä¸€ä¸ªçŠ¶æ€åœæœ?

A compact way is 
> "if the first one terminates in a particular state then so does the second, and vice versa."

```coq
Definition cequiv (c1 c2 : com) : Prop :=
  âˆ€(st st' : state),
    (st =[ c1 ]â‡?st') â†?(st =[ c2 ]â‡?st'). 
```

### Example 1 - Simple (but demonstrated) 

```coq
Theorem skip_left : forall c,
  cequiv (SKIP;; c) c.
Proof.
  intros c st st'. split; intros H.
  - (* -> *)         
    inversion H; subst.  (* inverse E_Seq   *)
    inversion H2. subst. (* inverse E_Skip  *)
    assumption.
  - (* <- *)             (* reversely *)
    apply E_Seq with st. (* apply E_Seq *)
    apply E_Skip.        (* apply E_Skip *)
    assumption.
Qed.
```

Noticed that the `inversion` is like use the _inverse function_ of constructors.


### Example 2 - WHILE true non-terminating

one interesting theorem is that we can prove `WHILE <things â‡?true>` is not terminating.
and is equivalent to _any other non-terminating program_, e.g. `WHILE BTrue DO SKIP END`: (å› ä¸ºæˆ‘ä»¬çš„ã€Œç­‰ä»·ã€åªè¦æ±‚åŒã€Œå‘æ•£ã€å³å?

```coq
Theorem WHILE_true : âˆ€b c,
  bequiv b true â†?
  cequiv
    (WHILE b DO c END)
    (WHILE true DO SKIP END).
```


### Example 3 - Loop Unrolling

> _any number of copies of the body_ can be "unrolled" without changing meaning

```coq
Theorem loop_unrolling : âˆ€b c,
  cequiv
    (WHILE b DO c END)         
    (TEST b THEN (c ;; WHILE b DO c END) ELSE SKIP FI).    (** å±•å¼€ä¸€å±?**)
```


### Example 4 - Use of extenionality å¤–å»¶æ€?

`x !-> m x ; x` is same map with `m` by extenionality!

```coq
Theorem identity_assignment : âˆ€x,
  cequiv (x ::= x) SKIP.
```





Properties of Behavioral Equivalence è¡Œä¸ºç­‰ä»·çš„æ€§è´¨
--------------------------------------------


### ç­‰ä»·å…³ç³» (Equivalence)

> è‡ªåæ€§ï¼ˆreflexiveï¼‰ã€å¯¹ç§°æ€§ï¼ˆsymmetricï¼‰å’Œä¼ é€’æ€?ï¼ˆtransitiveï¼?


### åŒä½™å…³ç³»ï¼ˆCongruenceï¼?

> That is, the equivalence of two subprograms implies the equivalence of the larger programs in which they are _embedded_
> å¦‚æœä¸¤ä¸ªå­ç¨‹åºç­‰ä»·ï¼Œé‚£ä¹ˆå½“äºŒè€…æ‰€åœ¨çš„æ›´å¤§çš„ç¨‹åºä¸­_åªæœ‰äºŒè€…ä¸åŒ_æ—¶ï¼Œ è¿™ä¸¤ä¸ªæ›´å¤§çš„ç¨‹åºä¹Ÿç­‰ä»?


              aequiv a1 a1'
      -----------------------------
      cequiv (x ::= a1) (x ::= a1')

              cequiv c1 c1'
              cequiv c2 c2'
         --------------------------
         cequiv (c1;;c2) (c1';;c2')


> è¿™ä¸ªæœ¯è¯­åº”è¯¥æ˜¯æ¥è‡ªæŠ½è±¡ä»£æ•?: èƒ½åœ¨è¿ç®—ä¸‹ä¿æŒçš„ç­‰ä»·å…³ç³»
> ...in the sense that algebraic operations done with equivalent elements will yield equivalent elements.
> [Congruence relation](https://en.wikipedia.org/wiki/Congruence_relation)

```coq
Theorem CAss_congruence : âˆ€x a1 a1',     (** cequiv æ˜¯é›†å?commands ä¸Šçš„ç­‰ä»·å…³ç³» **)
  aequiv a1 a1' â†?
  cequiv (CAss x a1) (CAss x a1').       (** åœ?`CAss` è¿™ä¸ª operation ä¸‹ä¿æŒç­‰ä»?=> åŒä½™ **)
  cequiv (x ::= a1) (x ::= a1').         (** æˆ–ï¼Œåœ?`::=` è¿™ä¸ª command ä¸‹ä¿æŒç­‰ä»?=> åŒä½™ **)
```

> åœ?commands ä¸Šç­‰ä»·ä½†ä¸åŒä½™çš„å…³ç³»?

I guess..."both terminating" relation?
which is equivalence relation on commands, but the equivalence would not be maintained after, say `C_WHILE` operation.



### Example - Using Congruence

```coq
Example congruence_example:
  cequiv
    (* ç¨‹åº 1ï¼?*)
    (X ::= 0;;
     TEST X = 0
     THEN
       Y ::= 0
     ELSE
       Y ::= 42
     FI)
    (* ç¨‹åº 2ï¼?*)
    (X ::= 0;;
     TEST X = 0
     THEN
       Y ::= X - X (* <--- è¿™é‡Œä¸åŒ *)
     ELSE
       Y ::= 42
     FI).
Proof.
  apply CSeq_congruence.
  - apply refl_cequiv.
  - apply CIf_congruence.
    + apply refl_bequiv.
    + apply CAss_congruence.     (** <--- åŒ–ç®€åˆ°åªéœ€è¦è¯æ˜?aequiv 0 (X - X) **) 
      unfold aequiv. simpl.
      * symmetry. apply minus_diag.
    + apply refl_cequiv.
Qed.
```





Program Transformations ç¨‹åºå˜æ¢
------------------------------

> A program transformation is _sound_ if it preserves the behavior of the original program.
> å¦‚æœä¸€ä¸ªç¨‹åºå˜æ¢ä¿ç•™äº†å…¶åŸå§‹è¡Œä¸ºï¼Œé‚£ä¹ˆå®ƒå°±æ˜¯_å¯é _çš?

æˆ‘ä»¬å¯ä»¥å®šä¹‰åœ¨ä¸åŒé›†å?`aexp, bexp, com` ä¸Šçš„ sound å…³ç³»ï¼?
(æœ‰è¶£çš„æ˜¯ï¼Œ`Inductive` å®šä¹‰çš„é `Prop` çš?`Type`, ç¡®å®å°±æ˜¯ `Set`, è¿™æ˜¯ä¸€ç§?PL å’Œæ•°å­¦çš„ Correspondence)
- å½“æˆ‘ä»¬çš„ datatype æ˜?constructor æ—?=> ä¸äº¤å¹?
- å½“æˆ‘ä»¬çš„ datatype æœ?recursive   æ—?=> é›†åˆçš„é€’å½’å®šä¹‰


```coq
Definition atrans_sound (atrans : aexp â†?aexp) : Prop :=
  âˆ€(a : aexp), aequiv a (atrans a).
Definition btrans_sound (btrans : bexp â†?bexp) : Prop :=
  âˆ€(b : bexp), bequiv b (btrans b).
Definition ctrans_sound (ctrans : com â†?com) : Prop :=
  âˆ€(c : com), cequiv c (ctrans c).
```


### Constant Folding å¸¸é‡æŠ˜å 

> An expression is _constant_ when it contains no variable references.
> ä¸å¼•ç”¨å˜é‡çš„è¡¨è¾¾å¼ä¸º_å¸¸é‡_

> Constant folding is an _optimization_ that finds constant expressions and replaces them by their values.
> å¸¸é‡æŠ˜å æ˜¯ä¸€ç§æ‰¾åˆ°å¸¸é‡è¡¨è¾¾å¼å¹¶æŠŠå®ƒä»¬æ›¿æ¢ä¸ºå…¶å€¼çš„ä¼˜åŒ–æ–¹æ³•ã€?


### Soundness of Constant Folding

#### `aexp`

```coq
Theorem fold_constants_aexp_sound :
  atrans_sound fold_constants_aexp.
Proof.
  unfold atrans_sound. intros a. unfold aequiv. intros st.
  
(** è¿™ä¸ªæ—¶å€™çš„çŠ¶æ€ï¼š**)

  a : aexp
  st : state
  ============================
  aeval st a = aeval st (fold_constants_aexp a)
  
```

#### `bexp`

è¯æ˜ `btrans_sound fold_constants_bexp.` è¦éš¾ä¸€äº›ï¼Œå› ä¸ºå…¶ä¸­è¿˜ç”¨åˆ°äº† `fold_constants_aexp`, æ‰€ä»¥æˆ‘ä»¬éœ€è¦ä¸€äº›æŠ€å·?

```coq
(** å¦‚æœä¸è®°ä½è€Œæ˜¯ç›´æ¥ destruct çš„è¯ï¼Œè¿™éƒ¨åˆ†ä¿¡æ¯å°±ä¸¢å¤±äº† **)
    remember (fold_constants_aexp a1) as a1' eqn:Heqa1'.
    remember (fold_constants_aexp a2) as a2' eqn:Heqa2'.

(** ä¿ç•™äº†è¿™éƒ¨åˆ†ä¿¡æ¯çš„ç›®çš„æ˜¯ï¼Œä½¿ç”?aexp çš„å¯é æ€§å®šç†æ¥å»ºç«‹ aexp ä¸?å€?çš„å…³ç³?**)
    replace (aeval st a1) with (aeval st a1') by
       (subst a1'; rewrite <- fold_constants_aexp_sound; reflexivity).
    replace (aeval st a2) with (aeval st a2') by
       (subst a2'; rewrite <- fold_constants_aexp_sound; reflexivity).

(** æœ€åæ‰åˆ†ç±»è®¨è®º **)
    destruct a1'; destruct a2'; try reflexivity.
```

#### `cmd`

ä¸»è¦æŠ€å·§åœ¨äºé…åˆä½¿ç”?`Congruence` ä¸?`IH` è§£å†³å¤§éƒ¨åˆ?caseï¼Œç„¶ååˆ†ç±»è®¨è®?`fold_constants_bexp` ç”?`sound` åšæ›¿æ¢è§£å†³å‰©ä½?case.



### Soundness of (0 + n) 

ç±»ä¼¼ï¼Œä½†æ˜¯æ¥ä¸‹æ¥æˆ‘ä»¬å°±å¯ä»¥è¯æ˜å…ˆ ` fold_constants` å†?`optimize_0plus` ä¹Ÿæ˜¯ sound çš?
è¿™é‡Œæˆ‘æ›´ general å¾—è¯æ˜äº† `ctrans` å…³ç³»çš„ä¼ é€’æ€§ï¼š

```coq
Theorem trans_ctrans_sound : forall tr1 tr2,
  ctrans_sound tr1 -> 
  ctrans_sound tr2 -> 
  ctrans_sound (fun c => tr2 (tr1 c)).
```






Proving Inequivalence è¯æ˜ç¨‹åºä¸ç­‰ä»?
-----------------------------

åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œ`subst_aexp` æ˜?sound å¾—ï¼Œè¢«ç§°ä¸?_Constant Propagation_ (å¸¸é‡ä¼ æ’­)

```coq
(**    [X := 42 + 53](Y + X)  =>  Y + (42 + 53)    **)
Example subst_aexp_ex :
  subst_aexp X (42 + 53) (Y + X)%imp = (Y + (42 + 53))%imp.
Proof. reflexivity. Qed.
```

æ‰€ä»¥æˆ‘ä»¬æ–­è¨€è¿™ä¹ˆåšæ˜¯ always sound å¾—ï¼š 

```coq
Definition subst_equiv_property := âˆ€x1 x2 a1 a2,
  cequiv (x1 ::= a1;; x2 ::= a2)
         (x1 ::= a1;; x2 ::= subst_aexp x1 a1 a2).
```

ç„¶è€Œå¦‚æ?`a1` ä¸æ˜¯å¸¸é‡ï¼Œå‰¯ä½œç”¨å¾ˆå®¹æ˜“è®©è¿™ä¸ªè½¬æ¢ unsound
é‚£ä¹ˆæ€ä¹ˆè¯æ˜ `Â¬subst_equiv_property` (å³è¯¥æ€§è´¨ä¸æˆç«?? ä¸¾ä¸€ä¸ªåä¾‹å°±å¥?


Informal proof
- provide a witness 

Formal
- give counterexamples via `remember`, then show `âŠ¥`.

```coq
(** ç»™å‡ºä¸€ç»„åä¾‹ï¼Œä½¿ç”¨æ€§è´¨è¯æ˜ä»–ä»¬ cequiv **)

  remember (X ::= X + 1;;
            Y ::= X)%imp     as c1.
  remember (X ::= X + 1;;
            Y ::= X + 1)%imp as c2.
  assert (cequiv c1 c2) by (subst; apply Contra).
  
(* => *)  Heqc1 : c1 = (X ::= X + 1;; Y ::= X)%imp
          Heqc2 : c2 = (X ::= X + 1;; Y ::= X + 1)%imp
          H : cequiv c1 c2
          ============================
          False
    
    
(** ç»™å‡ºä»–ä»¬å°?eval å‡ºä¸åŒçš„ heap **)

  remember (Y !-> 1 ; X !-> 1) as st1.
  remember (Y !-> 2 ; X !-> 1) as st2.
  assert (H1 : empty_st =[ c1 ]=> st1);
  assert (H2 : empty_st =[ c2 ]=> st2);

  apply H in H1. (** ä½¿ç”¨ H : cequiv c1 c2 , æˆ‘ä»¬å¾—åˆ° **)
  
(* => *)  H1 : empty_st =[ c2 ]=> st1
          H2 : empty_st =[ c2 ]=> st2
          ============================
          False


(** åˆ©ç”¨ ceval çš?deterministic **)

  assert (Hcontra : st1 = st2)
    by (apply (ceval_deterministic c2 empty_st); assumption).
    
(* => *)  Hcontra : st1 = st2
          ============================
          False

    
(** st1, st2 are map, which are actually function! 
    è¿™æ—¶æˆ‘ä»¬å¯ä»¥åç”¨ functional extenionalityï¼Œç›´æ?apply Y ç„¶å discrinminate **)

  assert (Hcontra' : st1 Y = st2 Y)
    by (rewrite Hcontra; reflexivity).
  subst. inversion Hcontra'.  Qed.
```




Extended Exercise: Nondeterministic Imp 
---------------------------------------

> HAVOC roughly corresponds to an _uninitialized variable_ in a low-level language like C. 
> After the HAVOC, the variable holds a fixed but arbitrary number.

æˆ‘ä»¬å¢åŠ ä¸€ä¸?`HAVOC X` è¯­å¥ï¼ˆå¤§ç¾éš¾ï¼‰ï¼Œä¼šä¸º X éšæœºèµ‹ä¸€ä¸ªå€?..ç±»ä¼¼äºã€Œæœªåˆå§‹åŒ–å˜é‡ã€?


```coq
Inductive com : Type :=
  ...
  | CHavoc : string â†?com. (* <--- æ–°å¢ *)

Notation "'HAVOC' l" :=
  (CHavoc l) (at level 60) : imp_scope.
  

Inductive ceval : com -> state -> state -> Prop :=
  ...
  | E_Havoc : forall st (n : nat) x,
      st =[ HAVOC x ]=> (x !-> n)        (** can eval to arbitraty heap **)
```






---


# Small-Step


## deterministic

also the def of partial function?

`solve_by_inverts`

in LTac. (used to generate proof)
LTac doesn't have _termination check_. (might not be able to find...)

`match` is back-tracking point.


number passing in = depth of the iteration/recursion




---


`ST_Plus2` need `value v1`. not redundant with `ST_Plus1`
we might have things not `value` but cannot take step as well.


---

Strong Progress


Normal form

= no relation related to (so cannot step to)


vs Value...


`destruct (apply t)`. 
can we do that?


---

Slide Q&A.



value_not_sae_as normal_form

e.g (1+2) + 7
e.g. 3 + 7


---

One-step

* plus
* left  + 0
* right + 0

Inf-step -> Inf terms

go from 3 to `3+0`


---


Stuck


No StepR

0 term can step into


---


Multi-Step Reduction `->*`

```coq
Inductive multi {X : Type} (R : relation X) : relation X :=
  | multi_refl : âˆ€(x : X), multi R x x
  | multi_step : âˆ€(x y z : X),
                    R x y â†?
                    multi R y z â†?
                    multi R x z.
```


can be either defined as a "head + tail" style (or "tail + head" style), or "refl + trans" style (as in `Rel.v`).

the `trans` relation are underteministic  in terms of the transtive relation using. (you can throw infinitely many `trans` constructors in)

> having multiple form so we can jump back and forth to pick one easier for proof.


--- 

PLT PM lang

multiple smallstep relation can be markded deepner state.qjw
er state.

---

IMP


`astep` no need for `value``

for `If`, in PLT we have 2 rules for T/F.
here we can compute...


---



Par w/o Concurrency is deterministic
(not vice versa)

suddenly `/ ->* /` tuple




