---
published: false
title: "ã€ŒSF-PLFã€? Stlc"
subtitle: "Programming Language Foundations - The Simply Typed Lambda-Calculus"
layout: post
author: "Hux"
header-style: text
hidden: true
tags:
  - SF (è½¯ä»¶åŸºç¡€)
  - PLF (ç¼–ç¨‹è¯­è¨€åŸºç¡€)
  - Coq
  - ç¬”è®°
---

this chapter:
- (change to new syntax...)
- function abstraction
- variable binding  -- å˜é‡ç»‘å®š
- substitution      -- æ›¿æ¢


Overview
--------

"Base Types", only `Bool` for now.   -- åŸºç±»åž?
...again, exactly following TAPL.


```coq
t ::= 
    | x                         variable
    | \x:T1.t2                  abstraction       -- haskell-ish lambda
    | t1 t2                     application
    | tru                       constant true
    | fls                       constant false
    | test t1 then t2 else t3   conditional

T ::= 
    | Bool
    | T â†?T                     arrow type

-- example
\x:Bool. \y:Bool. x
(\x:Bool. \y:Bool. x) fls tru
\f:Boolâ†’Bool. f (f tru)
```

Some known Î»-idioms:
> two-arg functions are higher-order one-arg fun, i.e. curried
> no named functions yet, all "anonymous"  -- åŒ¿åå‡½æ•°


## Slide QA 1

1. 2
2. `Bool`, `fls`







Syntax
------

Formalize syntax.
things are, as usual, in the `Type` level, so we can "check" them w/ dependent type.

```coq
Inductive ty : Type :=
  | Bool : ty
  | Arrow : ty â†?ty â†?ty.

Inductive tm : Type :=
  | var : string â†?tm
  | app : tm â†?tm â†?tm
  | abs : string â†?ty â†?tm â†?tm
  | tru : tm
  | fls : tm
  | test : tm â†?tm â†?tm â†?tm.
```

> Noted that, `\x:T.t` (formally, `abs x T t`), the argument type is explicitly annotated (not inferred.)


å¦å¤–ï¼Œè¿™é‡Œä»‹ç»äº†ä¸€ä¸ªå° trick: ç”?`Notation` (æ›´æŽ¥è¿?å®?) è€Œéž `Defintion` ä½¿å¾—æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `auto`...

```coq
(** idB = \x:Bool. x **)
Notation idB := (abs x Bool (var x)).
```






Operational Semantics
---------------------


### Values å€?

- `tru` and `fls` are values
- what about function?
  1. `\x:T. t` is value iff `t` value. -- Coq 
  2. `\x:T. t` is always value         -- most FP lang, either CBV or CBN

Coq è¿™ä¹ˆåšæŒºå¥‡æ€ªçš„ï¼Œä¸è¿‡å¯¹ Coq æ¥è¯´: 
> terms can be considered equiv up to the computation VM (åœ¨å…¶é¡¹åŒ–ç®€å¯ä»¥åšåˆ°çš„èŒƒå›´å†…éƒ½ç®—ç›¸ç­‰)
> this rich the notion of Coq's value (æ‰€ä»?Coq çš„å€¼çš„æ¦‚å¿µæ˜¯æ¯”ä¸€èˆ¬è¦å¤§çš„)

Three ways to construct `value` (unary relation = predicate)

```coq
Inductive value : tm â†?Prop :=
  | v_abs : âˆ€x T t, value (abs x T t)
  | v_tru : value tru
  | v_fls : value fls.
```


### STLC Programs ã€Œç¨‹åºã€çš„æ¦‚å¿µä¹Ÿæ˜¯è¦å®šä¹‰çš„

- _closed_    = term not refer any undefined var = __complete program__
- _open term_ = term with _free variable_

> Having made the choice not to reduce under abstractions, we don't need to worry about whether variables are values, since we'll always be reducing programs "from the outside in," and that means the step relation will always be working with closed terms.

if we could reduce under abstraction and variables are values... What's the implication here? å§‹ç»ˆä¸æ‡‚...


### Substitution (IMPORTANT!) æ›¿æ¢

> `[x:=s]t` and pronounced "substitute s for x in t."

    (\x:Bool. test x then tru else x) fls   ==>    test fls then tru else fls


Important _capture_ example:

    [x:=tru] (\x:Bool. x)  ==>  \x:Bool. x     -- x is bound, we need Î±-conversion here
                           !=>  \x:Bool. tru


Informal definition...

    [x:=s]x               = s
    [x:=s]y               = y                     if x â‰?y
    [x:=s](\x:T11. t12)   = \x:T11. t12
    [x:=s](\y:T11. t12)   = \y:T11. [x:=s]t12     if x â‰?y
    [x:=s](t1 t2)         = ([x:=s]t1) ([x:=s]t2)
    ...

and formally:

```coq
Reserved Notation "'[' x ':=' s ']' t" (at level 20).
Fixpoint subst (x : string) (s : tm) (t : tm) : tm :=
  match t with
  | var x' â‡?if eqb_string x x' then s else t    (* <-- computational eqb_string *)
  | abs x' T t1 â‡?abs x' T (if eqb_string x x' then t1 else ([x:=s] t1))
  | app t1 t2 â‡?app ([x:=s] t1) ([x:=s] t2)
  ...
```

> Computable `Fixpoint` means _meta-function_! (in metalanguage, Coq here)


### å¦‚æžœæˆ‘ä»¬è€ƒè™‘ç”¨äºŽæ›¿æ¢æŽ‰æŸä¸ªå˜é‡çš„é¡?s å…¶æœ¬èº«ä¹Ÿå«æœ‰è‡ªç”±å˜é‡ï¼?é‚£ä¹ˆå®šä¹‰æ›¿æ¢å°†ä¼šå˜å¾—å›°éš¾ä¸€ç‚¹ã€?

Is `if x â‰?y` for function abstraction one sufficient?  -- åœ?PLT ä¸­æˆ‘ä»¬é‡‡å–äº†æ›´ä¸¥æ ¼çš„å®šä¹‰
> Only safe if we only consider `s` is closed term. 

Prof.Mtf:
> here...it's not really "_defining_ on closed terms". Technically, you can still write open terms.
> if we want, we could define the real `closed_term`...more works to prove things tho.

Prof.Mtf:
> In some more rigorous setting...we might define `well_typed_term`
> and the definition itself is the proof of `Preservation`! 


### Slide QA 2

1. (3)


### Reduction ï¼ˆbeta-reductionï¼?beta-å½’çº¦

Should be familar

                    value v2
          ----------------------------                   (ST_AppAbs)   until value, i.e. function  (Î²-reduction)
          (\x:T.t12) v2 --> [x:=v2]t12

                    t1 --> t1'
                ----------------                           (ST_App1)   reduce lhs, Function side
                t1 t2 --> t1' t2

                    value v1
                    t2 --> t2'
                ----------------                           (ST_App2)   reduce rhs, Arg side 
                v1 t2 --> v1 t2'


Formally,
(I was expecting they invents some new syntax for this one...so we only have AST)

```coq
Reserved Notation "t1 '-->' t2" (at level 40).
Inductive step : tm â†?tm â†?Prop :=
  | ST_AppAbs : âˆ€x T t12 v2,
         value v2 â†?
         (app (abs x T t12) v2) --> [x:=v2]t12
  | ST_App1 : âˆ€t1 t1' t2,
         t1 --> t1' â†?
         app t1 t2 --> app t1' t2
  | ST_App2 : âˆ€v1 t2 t2',
         value v1 â†?
         t2 --> t2' â†?
         app v1 t2 --> app v1 t2'
...
```


### Slide QA 3

1. (1)  `idBB idB -> idB`
2. (1)  `idBB (idBB idB) -> idB`
3. if () ill-typed `idBB (notB tru) -> idBB fls ....`
   - we don't type check in step
4. (3)  `idB fls`
5. NOT...ill-typed one & open term








Typing
------


### Typing Contexts ç±»åž‹ä¸Šä¸‹æ–?

we need something like environment but for Types.

> three-place typing judgment, informally written   -- ä¸‰å…ƒç±»åž‹æ–­è¨€

    Gamma âŠ?t âˆ?T
    
> "under the assumptions in Gamma, the term t has the type T."

```coq
Definition context := partial_map ty.
(X âŠ? T11, Gamma) 
```

Why `partial_map` here? 
IMP can use `total_map` because it gave default value for undefined var.


### Typing Relations


                              Gamma x = T
                            ----------------                            (T_Var)   look up
                            Gamma |- x \in T

                   (x |-> T11 ; Gamma) |- t12 \in T12
                   ----------------------------------                   (T_Abs)   type check against context w/ arg
                    Gamma |- \x:T11.t12 \in T11->T12

                        Gamma |- t1 \in T11->T12
                          Gamma |- t2 \in T11
                         ----------------------                         (T_App)
                         Gamma |- t1 t2 \in T12


```coq
Example typing_example_1 :
  empty âŠ?abs x Bool (var x) âˆ?Arrow Bool Bool.
Proof.
  apply T_Abs. apply T_Var. reflexivity. Qed.
```


`example_2`
- `eapply`
- `A` ?? looks like need need another environment to look up `A`...



### Typable / Deciable


> decidable type system = decide term if typable or not.
> done by type checker...

> can we prove...?
> `âˆ€ Î“ e, âˆ?Ï„, (Î“ âŠ?e : Ï„) âˆ?Â¬(Î“ âŠ?e : Ï„)` -- a type inference algorithm!

> Provability in Coq witness decidabile operations.


### show term is "not typeable"

Keep inversion till the contradiction.




