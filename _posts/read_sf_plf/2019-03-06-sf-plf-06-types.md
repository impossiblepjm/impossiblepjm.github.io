---
published: false
title: "ã€ŒSF-PLFã€? Types"
subtitle: "Programming Language Foundations - Type Systems"
layout: post
author: "Hux"
header-style: text
hidden: true
tags:
  - SF (è½¯ä»¶åŸºç¡€)
  - PLF (ç¼–ç¨‹è¯­è¨€åŸºç¡€)
  - Coq
  - ç¬”è®°
---

This chapter:
- typing relation                                             -- å®šåž‹å…³ç³»
- `type preservation` and `progress` (i.e. soundness proof)   -- ç±»åž‹ä¿ç•™ï¼Œå¯è¿›æ€?


Typed Arithmetic Expressions (Toy Typed Language)
-------------------------------------------------

The toy lang from `SmallStep` is too "safe" to demonstrate any __runtime (or dynamic) type errors__.  -- è¿è¡Œæ—¶ç±»åž‹é”™è¯?
So that's add some operations (common church numeral ones), and `bool` type.

...same teaching order as TAPL. In PLT, we went directly to STLC.

### Syntax

```coq
t ::= tru | fls | test t then t else t | zro | scc t | prd t | iszro t
```

```coq
Inductive tm : Type :=
  | tru : tm
  | fls : tm
  | test : tm â†?tm â†?tm â†?tm
  | zro : tm
  | scc : tm â†?tm
  | prd : tm â†?tm
  | iszro : tm â†?tm.

(* object language has its own bool / nat , è¿™é‡Œä¸ä½¿ç”?Coq (meta-language) æ¯”è¾ƒ pure ä¸€äº? *)
Inductive bvalue : tm â†?Prop :=
  | bv_tru : bvalue tru
  | bv_fls : bvalue fls.
Inductive nvalue : tm â†?Prop :=
  | nv_zro : nvalue zro
  | nv_scc : âˆ€t, nvalue t â†?nvalue (scc t).  (** æ³¨æ„è¿™é‡Œ nv_scc æ˜¯æè¿°æ‰€æœ?[scc t] æ˜?nvalue çš„ä¸€ä¸?constructor / tag **)

(* [value?] predicate *)
Definition value (t : tm) := bvalue t âˆ?nvalue t.
```


### Automation 

`Hint` are added to database to help with `auto`.
More details on `auto. eapply. eauto.` were mentioned in `lf/Auto`.

```coq
Hint Constructors bvalue nvalue.
Hint Unfold value.
Hint Unfold update.
```


### S.O.S

Small-step operational semantics...
can be made formally in Coq code:

```coq
Reserved Notation "t1 '-->' t2" (at level 40).
Inductive step : tm â†?tm â†?Prop :=
  | ST_TestTru : âˆ€t1 t2,
      (test tru t1 t2) --> t1
  ...
```



### "is stuck" vs. "can get stuck"  å¡ä½çš„é¡¹ vs. å°†ä¼šå¡ä½çš„é¡¹

Noticed that the small-step semantics doesn't care about if some term would eventually get stuck.


### Normal Forms and Values

> å› ä¸ºè¿™ä¸ªè¯­è¨€æœ?stuck çš„æƒ…å†µï¼Œæ‰€ä»?`value != normal form` (terms cannot make progress) 
> `possible_results_of_reduction = value | stuck` 

```coq
Notation step_normal_form := (normal_form step).
Definition stuck (t : tm) : Prop :=
  step_normal_form t âˆ?Â¬value t.
```


### Slide Q&A 1

1. Yes
2. No   `scc zro` is a value
3. No   is a value




### Typing

```coq
Inductive ty : Type :=
  | Bool : ty
  | Nat : ty.
```

Noticed that it's just a non-dependently-typed ADT, but `: ty` is written explcitly here...they are the same!


### Typing Relations

okay the funny thing...
it make sense to use `âˆˆ` here since `:` has been used by Coq.
but this notation is actually represented as `\in`. 
We suddenly switch to LaTex mode...

```coq
Reserved Notation "'|-' t '\in' T" (at level 40).
```

Noticed the generic `T` here. 
In PLT we sometimes treat them as "magic" _meta variable_, here we need to make the `T` explcit (we are in the meta-language).

    âŠ?t1 âˆ?Bool    âŠ?t2 âˆ?T    âŠ?t3 âˆ?T	
    ----------------------------------  (T_Test)
      âŠ?test t1 then t2 else t3 âˆ?T

```coq
| T_Test : âˆ€t1 t2 t3 T,     (** <--- explicit âˆ€ T **)
       âŠ?t1 âˆ?Bool â†?
       âŠ?t2 âˆ?T â†?
       âŠ?t3 âˆ?T â†?
       âŠ?test t1 t2 t3 âˆ?T
```

```coq
Example has_type_1 :
  âŠ?test fls zro (scc zro) âˆ?Nat.
Proof.
  apply T_Test.      (** <--- we already know [T] from the return type [Nat] **)
    - apply T_Fls.   (** âŠ?_ âˆ?Bool **)
    - apply T_Zro.   (** âŠ?_ âˆ?Nat  **)
    - apply T_Scc.   (** âŠ?_ âˆ?Nat  **)
       + apply T_Zro.
Qed.
```

> (Since we've included all the constructors of the typing relation in the hint database, the `auto` tactic can actually find this proof automatically.)


#### typing relation is a conservative (or static) approximation

> ç±»åž‹å…³ç³»æ˜¯ä¸€ä¸ªä¿å®ˆçš„ï¼ˆæˆ–é™æ€çš„ï¼‰è¿‘ä¼?

```coq
Example has_type_not :
  Â¬( âŠ?test fls zro tru âˆ?Bool ).
Proof.
  intros Contra. solve_by_inverts 2. Qed.   (** 2-depth inversions **)
```


### `Lemma` Canonical Forms å…¸èŒƒå½¢å¼ 

As PLT. 


### Progress (å¯è¿›æ€?

```coq
Theorem progress : âˆ€t T,
  âŠ?t âˆ?T â†?
  value t âˆ?âˆƒt', t --> t'.
```

> Progress vs Strong Progress?
Progress require the "well-typeness"! 

> Induction on typing relation.


### Slide Q&A

- partial function yes
- total function no 
  - thinking as our inference rules.
  - we could construct some terms that no inference rules can apply and get stucked.


### Type Preservation (ç»´åž‹æ€?

```coq
Theorem preservation : âˆ€t t' T,
  âŠ?t âˆ?T â†?  (** HT **)
  t --> t' â†? (** HE **)
  âŠ?t' âˆ?T.   (** HT' **)
```

> æŒ?PLT  çš„æ€è·¯ Induction on HTï¼Œéœ€è¦?inversion HE åŽ»æžšä¸¾æ‰€æœ‰æƒ…å†µæ‹¿åˆ?t' ä¹‹åŽè¯æ˜Ž HT'
> æŒ?PFPL çš„æ€è·¯ Inudction on HE, åªéœ€ inversion HTï¼Œå› ä¸?HT æ˜¯æŒ‰ reduction ç›¸åæ–¹å‘å®šä¹‰çš? 
> - reduction æ–¹å‘ï¼ŒAST top-down   e.g. (+ 5 5)   ----->   10
> - typing    æ–¹å‘ï¼ŒAST bottom-up  e.g. |- ..:N   |-----   |- (+ 5 5):N

```coq
Proof with eauto.
  intros t t' T HT HE.
  generalize dependent T.
  induction HE; intros T HT;
    inversion HT; subst...
  apply nvalue_in_nat...  (** é™¤äº† ST_PrdScc å…¨éƒ¨ inversion è§£å†³... **)
Qed.
```

> The preservation theorem is often called _subject reduction_,  -- ä¸»è¯­åŒ–ç®€
æƒ³è±¡ term æ˜¯ä¸»è¯­ï¼Œä»…ä»… term åœ¨åŒ–ç®€ï¼Œè€Œè°“è¯­å®¾è¯­ä¸å?

> one might wonder whether the opposity property â€?_subject expansion_ â€?also holds. -- ä¸»è¯­æ‹“å¼ 
No, æˆ‘ä»¬å¯ä»¥å¾ˆå®¹æ˜“ä»Ž `(test tru zro fls)` è¯æ˜Žå‡?`|- fls \in Nat`. -- åœæœºé—®é¢˜ (undecidable)



### Type Soundness (Type Safety)

> a well-typed term never get stuck. 

```coq
Definition multistep := (multi step).  (** <--- from SmallStep **)
Notation "t1 '-->*' t2" := (multistep t1 t2) (at level 40).

Corollary soundness : âˆ€t t' T,
  âŠ?t âˆ?T â†?
  t -->* t' â†?
  ~(stuck t').
Proof.
  intros t t' T HT P. induction P; intros [R S].
  destruct (progress x T HT); auto.
  apply IHP. apply (preservation x y T HT H).
  unfold stuck. split; auto. Qed.
```

Induction on `-->*`, the multi-step derivation. (i.e. the reflexive-transtive closure)

Noticed that in PLT, we explcitly write out what is "non-stuck".
But here is `~(stuck t')`
thus the proof becomes:

```coq
R : step_normal_form x    (** normal form **)
S : ~ value x             (** and not value **)
=======================
False                     (** prove this is False **)
```

The proof is weird tho.





