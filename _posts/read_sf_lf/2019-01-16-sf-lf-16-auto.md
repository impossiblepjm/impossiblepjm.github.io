---
published: false
title: "ã€ŒSF-LCã€?6 Auto"
subtitle: "Logical Foundations - More Automation"
layout: post
author: "Hux"
header-style: text
hidden: true
tags:
  - LF (é€»è¾‘åŸºç¡€)
  - SF (è½¯ä»¶åŸºç¡€)
  - Coq
  - ç¬”è®°
---

- `auto` - proof search
- `Ltac` - automated forward reasoning (hypothesis matching machinery)
- `eauto`, `eapply` - deferred instantiation of existentials



`Ltac` macro
------------

```coq
Ltac inv H := inversion H; subst; clear H.

(** later in the proof... **)
inv H5.
```



The `auto` Tactic
-----------------

> `auto` can free us by _searching_ for a sequence of applications that will prove the goal:

```coq
intros P Q R H1 H2 H3.
apply H2. apply H1. assumption.


(** can be replaced by... **)
auto.
```

`auto` solves goals that are solvable by _any combination_ of 
- `intros`
- `apply` (of hypotheses from the _local_ context, by default)


> ä½¿ç”¨ auto ä¸€å®šæ˜¯â€œå®‰å…¨â€çš„ï¼Œå®ƒä¸ä¼šå¤±è´¥ï¼Œä¹Ÿä¸ä¼šæ”¹å˜å½“å‰è¯æ˜çš„çŠ¶æ€ï¼š auto è¦ä¹ˆå®Œå…¨è§£å†³å®ƒï¼Œè¦ä¹ˆä»€ä¹ˆä¹Ÿä¸åšã€?

> Proof search could, in principle, take an arbitrarily long time,
> so there are limits to how far auto will search by default.  (i.e. `5`)

```coq
Example auto_example_3 : âˆ€(P Q R S T U: Prop),
  (P â†?Q) â†?
  (Q â†?R) â†?
  (R â†?S) â†?
  (S â†?T) â†?
  (T â†?U) â†?
  P â†?
  U.
Proof.
  (* å½?auto æ— æ³•è§£å†³æ­¤ç›®æ ‡æ—¶ï¼Œå®ƒå°±ä»€ä¹ˆä¹Ÿä¸åš *)
  auto.
  (* å¯é€‰çš„å‚æ•°ç”¨æ¥æ§åˆ¶å®ƒçš„æœç´¢æ·±åº¦ï¼ˆé»˜è®¤ä¸º 5ï¼? 6 å°±åˆšå¥½èƒ½è§£å†³äº†ï¼ *)
  auto 6.
Qed.
```


### Hint Database æç¤ºæ•°æ®åº?

> `auto` auto considers a __hint database__ of other lemmas and constructors.
> common lemmas about _equality_ and _logical operators_ are installed by default.

> just for the purposes of one application of `auto` 
> æˆ‘ä»¬å¯ä»¥ä¸ºæŸæ¬?`auto` çš„è°ƒç”¨æ‰©å±•æç¤ºæ•°æ®åº“ï¼Œ`auto using ...` 

```coq
Example auto_example_6 : âˆ€n m p : nat,
  (n â‰?p â†?(n â‰?m âˆ?m â‰?n)) â†?
  n â‰?p â†?
  n = m.
Proof.
  intros.
  auto using le_antisym.
Qed.
```


### Global Hint Database æ·»åŠ åˆ°å…¨å±€æç¤ºæ•°æ®åº?

```coq
Hint Resolve T.          

Hint Constructors c.

Hint Unfold d.
```


### `Proof with auto.`

Under `Proof with t`, `t1...` == `t1; t`.




Searching For Hypotheses
------------------------

å¯¹äºå¾ˆå¸¸è§çš„ä¸€ç§çŸ›ç›¾æƒ…å½¢ï¼š

```coq
H1: beval st b = false
H2: beval st b = true
```

`contradiction` å¹¶ä¸èƒ½è§£å†³ï¼Œå¿…é¡» `rewrite H1 in H2; inversion H2`.

1. å®ï¼š

```coq
Ltac rwinv H1 H2 := rewrite H1 in H2; inv H2.

(** later in the proof... **)
rwinv H H2.
```

2. `match goal` è°ƒç”¨å®?

```coq
Ltac find_rwinv :=
  match goal with
    H1: ?E = true,
    H2: ?E = false
    âŠ?_ â‡?rwinv H1 H2
  end.
  
(** later in the proof... **)
induction E1; intros st2 E2; inv E2; try find_rwinv; auto. (** ç›´æ¥è§£å†³æ‰€æœ‰çŸ›ç›?case **)
- (* E_Seq *)
  rewrite (IHE1_1 st'0 H1) in *. auto.
- (* E_WhileTrue *)
  + (* b æ±‚å€¼ä¸º true *)
    rewrite (IHE1_1 st'0 H3) in *. auto. Qed.
```

å¯ä»¥çœ‹åˆ°æœ€ååªå‰©è¿™ç§æ”¹å†™å½¢å¼?..æˆ‘ä»¬ä¹ŸæŠŠä»–ä»¬è‡ªåŠ¨åŒ–äº†ï¼?

```coq
Ltac find_eqn :=
  match goal with
    H1: âˆ€x, ?P x â†??L = ?R,
    H2: ?P ?X
    âŠ?_ â‡?rewrite (H1 X H2) in *
  end.
```

é…åˆä¸?`repeat`...æˆ‘ä»¬å¯ä»¥ keep doing useful rewrites until only trivial ones are left.
æœ€ç»ˆæ•ˆæœï¼š

```coq
Theorem ceval_deterministic''''': âˆ€c st st1 st2,
    st =[ c ]â‡?st1 â†?
    st =[ c ]â‡?st2 â†?
    st1 = st2.
Proof.
  intros c st st1 st2 E1 E2.
  generalize dependent st2;
  induction E1; intros st2 E2; inv E2; 
    try find_rwinv;
    repeat find_eqn; auto.
Qed.
```

å³ä½¿æˆ‘ä»¬ç»?IMP åŠ ä¸Šä¸€ä¸?`CRepeat`ï¼ˆå…¶å®å°±æ˜?`DO c WHILE b`)ï¼?
ä¼šå‘ç°é¢ å€’ä¸€ä¸‹è‡ªåŠ¨åŒ–çš„é¡ºåºå°±èƒ?work äº?

```coq
  induction E1; intros st2 E2; inv E2; 
    repeat find_eqn; 
    try find_rwinv; auto.
```

å½“ç„¶ï¼Œè¿™ç§ã€Œè¶…çº§è‡ªåŠ¨åŒ–ã€?hyper-automation) å¹¶ä¸æ€»æ˜¯ç°å®ï¼Œä¹Ÿä¸å¥½è°ƒè¯•...



### The `eapply` and `eauto` variants

> æ¨è¿Ÿé‡è¯çš„å®ä¾‹åŒ–

æ¯”å¦‚å¯¹äº

```coq
Example ceval_example1:
  empty_st =[
    X ::= 2;;
    TEST X â‰?1
      THEN Y ::= 3
      ELSE Z ::= 4
    FI
  ]â‡?(Z !-> 4 ; X !-> 2).
Proof.
  (* æˆ‘ä»¬è¡¥å……äº†ä¸­é—´çŠ¶æ€?st'... *)
  apply E_Seq with (X !-> 2).
  - apply E_Ass. reflexivity.
  - apply E_IfFalse. reflexivity. apply E_Ass. reflexivity.
Qed.
```

æ²¡æœ‰ `with` å°±ä¼š `Error: Unable to find an instance for the variable st'`

ä½†å…¶å®?`st'` çš„å–å€¼åœ¨åé¢çš„æ­¥éª¤æ˜¯å¾ˆæ˜æ˜¾ï¼ˆå¾ˆå¥½ infer/unifyï¼‰çš„ï¼Œæ‰€ä»?`eapply` works.





