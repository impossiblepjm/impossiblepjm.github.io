---
published: false
title: "„ÄåSF-LC„Ä?1 Rel"
subtitle: "Logical Foundations - Properties of Relations"
layout: post
author: "Hux"
header-style: text
hidden: true
tags:
  - LF (ÈÄªËæëÂü∫Á°Ä)
  - SF (ËΩØ‰ª∂Âü∫Á°Ä)
  - Coq
  - Á¨îËÆ∞
---

> relation ‰∏éinjective/surjective/bijective function Á≠âÁõ∏ÂÖ≥ÁöÑÁü•ËØÜÂú?`5. Tactics` ÈáåÔºå‰∏∫‰∫ÜÈÅøÂÖçÊØèÊ¨°ÈÉΩË¶Å `grep` ÊàëÂú®ËøôÈáåÂÜô‰∏Ä‰∏ã„Ä?


Relations
---------


### Recalling [Relation](https://en.wikipedia.org/wiki/Finitary_relation)

from FCT/TAPL/Wiki...
> a possible connection between the components of a k-tuple.

I have been long confused with _Unary Relations vs. Binary Relation on the Same Set (homogeneous relation)_
I thought they were same...but turns out they are totally different!


#### Unary/1-place relation is __Predicate__ or __Property__! 

Either defined via set `X ‚ä?P` or `x ‚à?P`,
or defined via function `P : X -> Bool` or `P : X -> {‚ä? ‚ä§}`.
(usually used in Math. Logic)

Property = Indicator Fn = characteristic Fn = Boolean Predicate Fn = Predicate
- <https://en.wikipedia.org/wiki/Property_(mathematics)>
- <https://en.wikipedia.org/wiki/Indicator_function>


#### [Binary Relation/2-place relation](https://en.wikipedia.org/wiki/Binary_relation) 

Defined via two sets : `R ‚ä?X √ó Y` or `x, y ‚à?R` or `xRy`.  (where `x ‚à?X, y ‚à?Y`.)
or via function `R: X √ó Y -> Bool`.

##### [Homogeneous Relation ÂêåÁ±ªÔºàÁöÑÔºâÂÖ≥Á≥ª](https://en.wikipedia.org/wiki/Binary_relation#Homogeneous_relation)

Specifically! when `X = Y`, is called a _homogeneous relation_: 

Noticed that we are still concerning relations of __2 elements__!!, but they are from the same Set!
(while 1-place relation concerning only 1 element.)

    R ‚ä?X √ó X
    xRy where x ‚à?X, y ‚à?X

it's written/spoken _Binary_ relation __on/over__ Set `X`. 
Properties e.g. _reflexive, symmetric, transitive_, are all properties of "Homogeneous Relation"!



### Back to Coq

"relation" is a general idea. but in Coq standard lib it means "binary relation on _a_ set X"
> Coq `identifier` relation will always refer to a binary relation between some set and itself.

it's defined as _a family of Prop parameterized by two elements of `X`_:

```coq
Definition relation (X: Type) := X ‚Ü?X ‚Ü?Prop.

Check le : nat -> nat -> Prop.
Check le : relation nat.
```




Basic Properties
----------------

> ways to classifying relations.
> so theorems can be proved generically about certain sorts of relations

It's pretty fun to see all mathematical things defined in Coq!
(much more constructive)


### [Partial Function](https://en.wikipedia.org/wiki/Partial_function)

> function is defined as _a special kind of binary relation_. 

```coq
Definition partial_function {X: Type} (R: relation X) :=
  ‚àÄx y1 y2 : X, R x y1 ‚Ü?R x y2 ‚Ü?y1 = y2.
```

meaning that foreach input `x ‚à?X`, there is a _unique_ `y ‚à?Y` corresponded.

But this only establish a _partial function_. 
because it doesn't say anything about _totality_,
to define _total function_, we require `f` map every `x ‚à?X`. 

- [Total "Relation"](https://en.wikipedia.org/wiki/Connex_relation)

    ‚àÄx ‚àÄy (x ‚à?X ‚à?y ‚à?X) ‚á?(xRy ‚à?yRx).

totally different with _total function_ but ask the binary relation holds between every pair.


### Reflexive

```coq
Definition transitive {X: Type} (R: relation X) :=
  ‚àÄa b c : X, (R a b) ‚Ü?(R b c) ‚Ü?(R a c).
```

### Transitive

```coq
Definition transitive {X: Type} (R: relation X) :=
  ‚àÄa b c : X, (R a b) ‚Ü?(R b c) ‚Ü?(R a c).
```

### Symmetric & Antisymmetric

```coq
Definition symmetric {X: Type} (R: relation X) :=
  ‚àÄa b : X, (R a b) ‚Ü?(R b a).
  
Definition antisymmetric {X: Type} (R: relation X) :=
  ‚àÄa b : X, (R a b) ‚Ü?(R b a) ‚Ü?a = b.
```

#### Antisymmetric vs Asymmetric vs Non-symmetric (ÂèçÂØπÁß?vs. ÈùûÂØπÁß?vs. ‰∏?ÂØπÁß∞)

A relation is __asymmetric__ if and only if it is both antisymmetric and irreflexive
e.g. `<=` is neither symmetric nor asymmetric, but it's antisymmetric...
ÂèçÂØπÁß? ÂèØ‰ª•Ëá™Âèç (Âè™ËÉΩ reflexive Êó∂ÂØπÁß? `<=`
ÈùûÂØπÁß? ‰∏çËÉΩËá™Âèç `<`
‰∏çÂØπÁß? ‰∏çÊòØÂØπÁß∞ 



### Equivalence

```coq
Definition equivalence {X:Type} (R: relation X) :=
  (reflexive R) ‚à?(symmetric R) ‚à?(transitive R).
```


### Partial Orders 

A partial order under which _every pair_ of elements is _comparable_ is called a __total order__ or __linear order__
In the Coq standard library it's called just `order` for short:

```coq
Definition order {X:Type} (R: relation X) :=
  (reflexive R) ‚à?(antisymmetric R) ‚à?(transitive R).
```


### Preorders 

a.k.a quasiorder

The _subtyping_ relations are usually preorders.
> (TAPL p185) because of the record permutation rule...there are many pairs of distinct types where each is a subtype of the other.

```coq
Definition preorder {X:Type} (R: relation X) :=
  (reflexive R) ‚à?(transitive R).
```





Reflexive, Transitive Closure
-----------------------------

> [Closure](https://en.wikipedia.org/wiki/Closure_(mathematics)#Binary_relation_closures)
> Closure can be considered as [Operations on bin-rel](https://en.wikipedia.org/wiki/Binary_relation#Operations_on_binary_relations)

As properties such as _reflexive, transitive_, 
the __blah blah Closure__ are only talking about "homogeneous relations" i.e., Relation on a SINGLE set.


### [Reflexive Closure](https://en.wikipedia.org/wiki/Reflexive_closure)

Def. smallest reflexive relation on `X` containing `R`.

Operationally, as a `=` operator on a binary relation `R`:

    R‚Å?= R ‚à?{‚Ä?x, x) | x ‚à?X‚Äâ}

and this obviously satisfy `R‚Å?‚ä?R`.


### [Transitive Closure](https://en.wikipedia.org/wiki/Transitive_closure)

Def. smallest transitive relation on `X` containing `R`.

Operationally, as a `+` operator on a binary relation `R`:

    R+ = R ‚à?{ (x1,xn) | n > 1 ‚à?(x1,x2), ..., (xn-1,xn) ‚à?R }

We can also constructively and inductively definition using `R^i` where `i = i-transitivity away`.


### Reflexive, Transitive Closure

    R* = R‚Å?‚à?R+



### Why is it useful?

> The idea is that _a relation is extended_ s.t. 
>_the derived relation has the (reflexsive and) transitive property._ -- Prof. Arthur

> e.g.
> the "descendant" relation is the transitive closure of the "child" relation, 
> the "derives-star (‚áí‚ãÜ)" relation is the reflexive-transitive closure of the "derives (‚á?" relation.
> the "Œµ-closure" relation is the reflexive-transitive closure of the "Œµ-transition" relation.
> the "Kleene-star (Œ£‚ã?" relation is the reflexive-transitive closure of the "concatentation" relation.

Another way is to think them as "set closed under some operation".


### Back to Coq

```coq
Inductive clos_refl_trans {A: Type} (R: relation A) : relation A :=
  | rt_step x y (H : R x y) : clos_refl_trans R x y        (** original relation **)
  | rt_refl x : clos_refl_trans R x x                      (** reflexive  xRx              **)
  | rt_trans x y z                                         (** transitive xRy ‚à?yRz ‚Ü?xRz  **)
        (Hxy : clos_refl_trans R x y)
        (Hyz : clos_refl_trans R y z) :
        clos_refl_trans R x z.
```

The above version will generate 2 IHs in `rt_trans` case. (since the proof tree has 2 branches).

Here is a better "linked-list"-ish one. (we will exclusively use this style)

```coq
Inductive clos_refl_trans_1n {A : Type} (R : relation A) (x : A) : A ‚Ü?Prop :=
  | rt1n_refl : clos_refl_trans_1n R x x
  | rt1n_trans (y z : A)
      (Hxy   : R x y) 
      (Hrest : clos_refl_trans_1n R y z) :
      clos_refl_trans_1n R x z.
```

In later chapter, we will define a decorator `multi` that can take any binary relation on a set and return its closure relation:

```coq
Inductive multi (X : Type) (R : relation X) : relation X :=
  | multi_refl : forall x     : X,                         multi R x x
  | multi_step : forall x y z : X, R x y -> multi R y z -> multi R x z
```

We name it `step`, standing for _doing one step of this relation_, and then we still have the rest (sub-structure) satisfied the closure relation.

